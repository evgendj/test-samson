<?php

ДЕСТРУКТОР  - 893245
КОНСТРУКТОР - 576987
МАССИВ    --- *586
ООП       --- *5988
АБСТРАКТНЫЙ КЛАСС - МЕТОД  --------86245
ЦИКЛЫ     --- *123
СТАТИЧЕСКИЕ МЕТОДЫ И СВОЙСТВА  ---------863495
ФУНКЦИИ  ******795324
ФУНКЦИИ ВСТРОЕННЫЕ  *********7548632
РАБОТА С ФОРМАМИ  *************26547
SQL  *********3587632
GIT  *********34569871
МАТЕМАТИКА  **9563214

**************************  ПЕРЕМЕННЫЕ  ****************************************
// Начинается только с буквы или _ знак подчеркивания. Допускаются буквы (кириллицу лучше не использовать, хотя интерпретатор понимает их)
// Допускаются в имени цифры и _ . и еще какие-то символы из кодировки. Регистрочувствительно.
// Вначале переменной всегда знак доллара $
// Числа - выводятся даже с точкой и знаком.
echo -56.3;
// Не скупись на переменные, с ними код лучше читается.
// Переменная хранит не сам объект, а ссылку на объект. При присвоении переменной значения, выделяется оперативка для создания значения.
// Если на значение не ссылается ни один объект, то сборщик мусора удаляет значение из памяти.
--------------------------  ТИПЫ  ----------------------------------------------
  // PHP логически понимает переменные которые вводятся. Но тип можно указывать явно.
int, integer, long // целое число. Выяснить максимальный размер допустимого числа можно по функции
  // echo PHP_INT_MAX; // 9223372036854775807 (у 64 битной версии) - при выходе за этот диапазан преобразуется в float
  // При переводе дробного в целое, дробная часть отсекается. При переводе текста, преобразуется в 0. Если в начале текста есть цифра, преобразует в эту цифру.
double, float, real // Вещественное число, число с плавающей точкой. Или строка с таким числом. Обычная форма записи 346.1256.
  // Экспонециальная форма в виде произведения мантисы 3.461256 и соотв. степени числа 10 в степени 2.
  // Для числ меньше нуля степень отрицательная. 0.00012 = 1.2 х 10 в степени -4
  // В коде нет возможности использовать верхний регистр для записи степени, поэтому используют такую запись - х 10 = е+/- (для положительной степени + после е, для отриц. -)
  // 346.1256 = 3.461256 х 10 в ст. 2 = 3.461256е+2
  // 0.00012  = 1.2 х 10 в степени -4 = 1.2е-4
  // Под такое число выделяется диапазон 8 байтов - от +/- 2.23е-308 до +/- 1.79е308 - при выходе за диапазаон вместо числа выводится константа:
INF - бесконечность. Операции с INF дают INF // Это не тип, а константа
NAN - недопустимое число // Константа - любые операции с ней возвращают NAN
  // echo sqrt(-1); - выведет NAN
string // строка текста, используется для любых данных. Строка ограницена 2 Гб. Но php скрипт ограничен в объеме потребляемой памяти директивой limit (по умолчанию 128 мб)
  // '10' - считается строкой, но можно проводить математические действия. Но после мат. действий уже превращается в число.
array // массив
list // Я так понял этот тип годится для присвоения, не экспериментировал. Это тот числовой массив.
object // ссылка на объект.
resource // ресурс
boolean, bool // логический тип. Значение true или false
  // true = не пустая строка = ненулевое значение = истина = 1 НО!! С этой единицей не получится производить математические операции.
  // false = пустая строка = ложь = 0
null // константа, а так же тип.
callback, callable // функция обратного вызова
mixed // Может содержать все что угодно. Зависит от операндов.
void // Возвращают ложь или пустую строку.
--------------------------  ПЕРЕВОД В НУЖНЫЙ ТИП  ------------------------------
settype($a,$b) // Перевод первой переменной в тип, который хранится во второй переменной (можно в кав. сразу написать тип переводимый).
floatval($a) = doubleval($a) // Перевод переменной к вещественному числу.
strval($a) // Перевод в строку
intval($a[, $base]) // По умолчанию переведет в целочисленную переменную в десятичном формате. Но если вместо баз поставить 8, перевед в восьмиричный формат. Можно другие использовать.
unset($a) // приведение к null
  // Также можно приводить в нужный тип, просто поставив в скобках перед переменной тип:
$a = '10';
echo (int)$a . gettype((int)$a); // Выведет уже целочисленный тип
--------------------------  ОПРЕДЕЛЕНИЕ ТИПА  ----------------------------------
is_int() - возвращает true, если число целое
is_double() - возвращает true, если число действительное
is_infinite() - возвращает true, если бесконечное INF
is_nan() - возвращает true, если число NAN
is_string() - возвращает true, если строка
is_numeric() - возвращает true, если содержит цифры и точку, над такими переменными, даже если они строковые, можно проводить арифметические действия
is_bool() - возвращает true, если истина
is_scalar() - возвращает true, если значение один из перечисленных выше типов
is_null() - возвращает true, если значение null // Не скалярное, к слову
is_array() - возвращает true, если массив
is_object() - возвращает true, если содержит ссылку на объект
gettype() - вовращает строки, со значениями соответствующими типу
--------------------------  ОПЕРАЦИИ НАД ПЕРЕМЕННЫМИ  --------------------------
$a = 10; // Инициализация переменной. Нельзя использовать несуществующую переменную. Выйдет ошибка, но ошибки можно (но не рекомендуется) отключить. Лучше использовать @ для локального откл.
= // Оператор присваивания. Присваивать можно не только отдельной строкой, но прямо в выражении $a = ($b = 4) + 5;
=& // Жесткая ссылка (простая ссылка). Если изменить присвоить другое значение ссылающейся переменной, то это изменит значение переменной на которую ссылается первая.
  // На элементы массива можно тоже ссылаться. Если будет ссылка на несуществующую переменную, то она создастся со значением null, и таким же типом.
  // Если сделать ансет на ссылающуюся перменную, то удалится просто ссылка с этой переменной. Переменная на которую ссылаются будет без изменений.
$$ // Символическая переменная. Не стоит ей пользоваться.
  $right = "красная";
  $color = "right";
  echo $$color;
'строка' // Строка в апострофах. Ниже две последовательности, которые работают в такой строке. Все остальные символы выводятся как есть.
\' // Ставится если в строке в апострофах нужно написать апостроф там, где он должен интерпретироваться как нам надо
\\ // Трактуется как один обратный слэш \
"строка" // Строка в кавычках. Понимает переменные и можно использовать спецсимволы:
\n // символ новой строки
\r // символ возврата каретки
\t // символ табуляции
\$ // обозначается как $ , чтобы следующий за этим символом текст не интерепретировался как переменная.
\" // кавычка
\\ // обратный слэш       '
\xNN // символ с шестнадцатиричным кодом NN
> // Больше
< // Меньше
<= //Меньше или равно
>= // Больше или равно
<=> // Космический корабль - сравнение <=> - если левый операнд больше правого, возвращает положит. число и наоборот. Отличие от strcmp(a,b) - <=> преобразует числовые символьный переменные в числа.
  $b = 'carli' <=> 'bob'; // с следует после b - вернет положительное число.
  $b = '6 pack' <=> 55; // 6 меньше 55, вернет минус.
== // Равно
=== // Эквивалентно
|| // Логическое ИЛИ. or - отличается более низким приоритетом, можно в скобки не заключать
&& // Логическое И. and - отличается более низким приоритетом, можно в скобки не заключать
! // Логическое НЕ, Отрицание истинного значения. В условиях ! перед выражением сравнивает выражение с false и возвращает true, если выражение не истинно. И false если выражение истинно.
!= // Не равно a != b истина если а неравно б
!== // Не эквивалентно
// Коментарий строки
/* Комментарий
большого участка */
{} // {$some}a // Если в строке нужно такое написание, чтобы php правильно понял. Можно и так ${some}a. Значение массива в строке выводим либо так {$a['second']}, либо без апострофов и фигурных скобок $a[second]
<<< // here-документ, встраиваемые документы - Когда нужно вывести большой блок на экран. Ставится <<<MENU - три знака меньше и ограничитель, ниже код, затем еще раз ограничитель. В конце ограничитель только с нов. строки, может быть ; если нужно закончить функцию. Тип пишет, лучше от них отказаться. Если закавычить первый ограничитель (только ограничитель), то переменные не будет выводить - NOW-документ (актуальный документ).
  echo <<<MARKER // никаких пробельных символов тут
  Тут большой текст, тэги,
  с переносами чрез энтер
  MARKER; // тоже никаких символов
`команда` // строка в обратных апострофах заставляет php выполнить команду операционной системы.
+ // плюс
++ // инкремент - увеличение переменной на 1. $a++ - сначала выводит значение, потом плюсует. ++$a - сначала плюсует, потом отдает полученное значение.
+= // составная операция - $a += 1; Привабить 1 к $a
- // минус
-- // декремент - уменьшение переменной на 1.
/ // деление
* // умножение
** // Возведение в степень. Сначала число которое нужно возвести, затем степень после двух звездочек - echo 4**2. Аргумент может быть дробным.
% // Деление по модулю / деление без остатка (в математике - кратность) / вычисление остатка от деления. Работает только с целыми числами.
. // Конкотенация - слияние строк.
.= // Составное сцепление $message .= 'слияние'; значение переменной сольтся с тем что после равно // Строковая операция
a[n] // символ строки в позиции n // Строковая операция
@ // if (@$_REQUEST['doGo']) echo "Bbl Hажали KHOnKY!"; если значение еще не создано, то выдаст ошибку, чтобы эту ошибку октлючить, используем локальный оператор отключиния ошибки. Это быстрое решение. Однако при отладки эти ошибки нужно обрабатывать, поскольку ошибка может записываться в логи, и засорять их. Вот вариант без собаки - if (isset($_REQUEST['doGo'])) echo "Bbl Hажали KHOnKY!";
// Никода собаку не применяй перед включением другого докмуента - include, при вызове собственных функций, перед вызовом eval(). Не блокируй ошибку при использовани большого куска кода, потом можно не разобраться. Рекомендует использовать когда нужно трактовать необъявленную переменную или значение массива.
0 и "" // Пустая стркоа воспринимается как лож, а false == 0, значит 0 == ""
--------------------------  УСЛОВНЫЕ ОПЕРАЦИИ  ---------------------------------
?: // x ? y : z // если х истина, вернет у, в противном случае з
  $x = -17;
  $x = $x < 0 ? -$x : $x; // изменит на положительное число
// Если пропустить средний параметр между вопросом и двоеточием, то просто проверяет инициализированна ли переменная, если не ициализированна присвоит ей последнее значение.
  $a = $a ?: 1; // Если а не инициализированна, присвоит ей единицу. Если переменная существует, то остается в неизменном виде.
// Переменная ?: не проверяет, существует ли переменная, указанная в качестве первого операнда, поэтому нужно писать так if (isset($_REQUEST["doGo"]) ?: false) echo "KHonKa Haжатa!";
?? // Оператор проверяет автоматически на существование выражения, в случае его отсутствия не выводит ошибку. Принимая несколько операндов, он возвращает значение не равное null
  $z = 3;
  var_dump($x ?? Sy?? $z); // int(3)
$val= S_REQUEST["doGo"] ?? false;
--------------------------  БИТОВЫЕ ОПЕРАЦИИ  ----------------------------------
a & b // Результат - число с установленными битами, которые выставлены и в а и в б одновременно.
a | b // Результат - число с установленными битами, которые выставлены либо в а либо в б одновременно.
a ^ b // Результат - число с установленными битами, которые выставлены либо в а либо в б.
~ a // Результат, у которого на месте единиц в а стоят нули, и наоборот.
a << b // Результат - число, полученное поразрядным сдвигом а на б битов влево
a >> b // Результат - число, полученное поразрядным сдвигом а на б битов вправо

isset() // Проверка существования переменной. Возвр. ложь или истину.
unset() // Уничтожение переменной, полное. Этим же оператором можно уничтожить элементы массива, удаляется и ключ.

**************************  КОНСТАНТА  *****************************************
// Принято писать заглавными. Устанавливается один раз, переопределить нельзя. Выводится только конкотенацией. Имя не должно повторяться.
define($a, $b) // Определение константы с именем в а и значением в б. Если после б в скобках после запятой дописать $case_sen = false - регистр не будет учитываться.
  define("PI", 3.14); // Кавычки обязательны
  echo PI;
defined($a) // Вовращает правду если константа была определена.
constant($name) // Получаем значение константы с динамическим именем. В скобках имя этой констнты используемая через переменную
--------------------------  ПРЕДОПРЕДЕЛЕННЫЕ КОНСТАНТЫ  ------------------------
PHP_INT_MAX // содержит макс. число
PHP_INT_SIZE // количество байтов отводимое под числом
__FILE__ // Хранит имя файла, в котором запущен настойщий кода
__LINE__ // Хранит номер строки, которую обрабатывает интерпретатор в настойщий момент.
__FUNCTION__ // Имя текущей функции
__CLASS__ // Класса
PHP_VERSION // Версия интерпретатора
PHP_OS // Имя операционной системы
PHP_EOL // Символ конца строки на текущей платформе \n Linux, \r\n Win, \n\r Mac
true, false, null
**************************  КОНСТРУКЦИИ = инструкция  **************************
**************************  if-else УСЛОВНАЯ КОНСТРУКЦИЯ = инструкция  *********
if (12 == $proverim) {echo "Проверили!";}
// = Не путать == (сравнение - проверяется на равенство и возвращает true or false) с = (присваивание), чтобы не путаться, можно число ставить на первое место, тогда не будет перезаписана переменная, а php выдаст ошибку при одном =.
// Сравнение с плавающей точкой. Представление числа может отличаться от его абсолютного значения, т.е. после ,0000 может быть число, а показано только два нуля. Так что нужно сравнивать с допустимой погрешностью перед сравнение чисел.
// При сравнении строк, в одной из которых число, обе строки приравинваются к числовому типу.
// Оператор ! - не
if ($finished == false) {
	echo "Переменная не истина<br>";
} // равносильно следующему написанию:
if (! $finished2) {
	echo 'Переменная не истина';
}
// Логические операции и && - проверяет истину обоих выражений, или || - проверяет истинно ли хотя бы одно выражение.
// Если исход операции уже очевиден, то операция обрывается, даже если дальше будут функции
  $logic= 0 && (time() > 100); // Функция тайм так и не вызовется.
// При сравнивании строк с числом, строку всегда переводит в 0 либо в цифру которая стоит в начале значения
// Если в инструкциях одна команда, то можно не использовать фигурные скобки
  $proverim = 1;
  if ($proverim) {
  	echo "Естина, в переменной что-то есть";
  	echo " - $proverim.";
  } else {
  	echo "Переменная пустая! - false";
  }
  if ($proverim) {
  	echo ' Истина, в переменной $proverim что-то есть';
  } elseif ($proverim2) {
  	echo 'Естина, в переменной $proverim2 что-то есть';
  } elseif ($proverim3) {
  	echo 'Естина, в переменной $proverim3 что-то есть';
  } else {
  	echo " Все переменные ложные!";
  }
// Альтернативный код, можно использовать при встраивании php в html. Двоеточие используем в обязательном порядке.
/*
  <?php if (isset($_REQUEST['go'])):?>
    Привет, <?=$_REQUEST['name']?>!
  <?php else:?>
    <form action="<?=$_SERVER['REQUEST_URI']?>" method="POST">
    Ваше имя: <input type="text" name="name"><br />
    <input type="submit" name="go" value="Отослать!">
    </form>
  <?php endif?>
*/
**************************  ЦИКЛЫ - конструкции циклов  **********123***********
--------------------------  while  ---------------------------------------------
$i = 1; // Переменная для сравнеия условий, а так же счетчик
while ($i <= 5) { // Сравнение условия, если и меньше или равно 5 выполни код ниже, если выражение ложно, пропустить код функции и выполнять то, что под функцией.
	echo "<p>$i</p>"; // Выводится на экран
	$i++; // Плюсетеся 1 к счетчику (инкрементируется значение)
} // Тоже имеет альтернативный синтаксис while (): ... indwhile;
--------------------------  do while см break - continue  ----------------------
do {
  $i++; // Цикл сначала выполняет операцию
} while ($i <= 5); // затем проверяет условия, если истина, делает следующий цикл. Альт. нету, цикл используется редко.
--------------------------  for универсальный цикл  ----------------------------
for ($n = 1; $n <= 5; $n++) { // В скобках до первой ; инициализируются переменные или инициализирующее выражение; второе выражение проверочное; третье выражение итерационное - выполняется после каждого шага цикла. В иницилизирущем и итерационном выражениях можно добавлеть через запятую несколько выражений.
	echo "<p>$n</p>";
} // Так же есть альт. for (): операторы; endfor;
--------------------------  foreach  -------------------------------------------
// Цикл перебора значений массива - см. в массивах
--------------------------  break - continue  ----------------------------------
// Обрывает цикл, либо продолжает цикл с начала. В скобках цифрой можно добавить какой цикл подразумевается.
// Пример для избавления от лишних операторов
  <?php
    $WasError = 0; // индикатор ошибки - если не 0, то была ошибка
    // Если нажали кнопку Submit (с именем $doSubmit)...
    if (isset($_REQUEST['doSubmit'])) do {
      // Проверка входных данных
      if ($_REQUEST['reloads'] != 1+1+7) { $WasError = 1; break; }
      if ($_REQUEST['loader'] != "source") { $WasError = 1; break; }
      // и т. д. - здесь может быть множество других проверок.
      // ...
      // В этой точке данные точно в порядке. Обрабатываем их.
      echo "Вы внимательный человек, поздравляем!<br />";
      // Можно записать данные в файл.
      exit();
    } while (0);
    // Произошла ли ошибка?
    if ($WasError) {
      echo "Вы ответили неверно, попробуйте еще раз.";
    }
  ?>
  <!-- Выводим форму, через которую пользователь будет запускать этот
  сценарий, и, возможно, отображаем сообщение об ошибке в случае,
  если $WasError != 0. -->
  <form action="<?=$_SERVER['REQUEST_URI']?>" method="POST">
    Число перезагрузок: <input type="text" name="reloads"><br />
    Загрузочная программа: <input type="text" name="loader"><br />
    <input type="submit" name="doSubmit" value="Ответить на вопросы">
  </form>
--------------------------  switch-case  ---------------------------------------
// Часто вместо условной конструкции употребляют эту, для сокращения условий
switch (выражение) { // вычисляется выражение
  case значение1: команды1; [break;] // проходится по кейсам ищет значение равное результату выражения.
  ....
  case значениеN: командыN; [break;] // если строка найдена, выполняет команды. Брэйк обрывает скрипт, после вып. ком.
  [default: команды_по_умолчанию; [break]] // Можно задать команды по умолчанию.
}
endswitch // альт. - вместо первой { - : (без пробела), вместо } - endswitch
--------------------------  goto  ----------------------------------------------
$i = 0;
begin: // Первая метка
$i++;
echo "$i<br />";
if ($i >= 10) goto finish; // Перейти ко второй переменной, если истина, и соответственно выход из цикла.
goto begin; // Перейти к первой метке, идет зацикливание.
finish: // Вторая метка
// Эта конструкция усложняет код, устарело, но работает. Это удобная замена многоуровневого break
--------------------------  require - include  ---------------------------------
require 'file.php'; // подключение другого файла. Код можно сохранить в одном файле, а подключить к другой странице. Ниже команда, которая говорит, что нужно прервать код и выполнить код из файла, затем вернуться обратно к текущему файлу. Если файл не обнаружен или внутри недопустимый код, программа прервется. Пути могут относительные и абсолютные. Также интерпритатор обращается по путям к директиве конфигурации include_paath
include 'file.php'; // точно также подключает документ, НО!!! Если возникнут трудности при загрузке, программа не остановится, а просто пропустит подключаемый файл. В большинстве случаев использовать нецелесообразно.
// Применяй инструкцию с целью подключения шапки и подвала, в других ситуацях лучше использовать require_once
--------------------------  require_once - include_once  -----------------------
require_once работает так же require, но если затребованный файл уже был включен, инструкция проигнорируется. PHP хранит полные имена подкл. файлов. Рекомендуется отказаться от пред. инст. без _once
--------------------------  другие инструкции  ---------------------------------
function // объявление функции
return // возврат из функции
yield // передача управления из генератора
class // объявление класса
new // создание объекта
var, private, static, public // определение свойства класса
throw // генерация исключения
try-catch // перехват исключения
.. и тд.

**************************  МАССИВ  ********************586*********************
// Массив - контейнер содержащий многие значения. Элементы массива состоят из ключа и значения. Массив не может быть в ключе, только скалярные величины. Значение может внутри иметь ложь, истину, может быть другим массивом.
$vegetables = array('corn' => 'yellow', // создаем ассоциативный массив
					'beet' => 'red',
					'carrot' => 'orange');
$dinner = array(0 => 'corn and 1', // создаем числовой массив
				1 => 'beet and 2',
				'admin' => 'corn and 3',
				2600 => 'Atari');
// Числовой массив по сути тоже является ассоциативным. Не стоит полагаться в числовом на нумарацию. Чтобы быть в ней уверенным, можно сделать сортировку или пересоздать массив
$names= array(); $names= []; // создание пустого массива
// Скалярные данные - данные имеющие единственное значения: число, фрагмент текста, false, true. Нескалярные - массив.
// В ключах и значениях допускаются как числовые так и строковые, так и смешнные типы данных, даже переносы допускаются. Массив может перезаписаться переменной, если ниже использовать то же имя и присвоить переменную. Так же и переменная может измениться в масив, но только не прокатит если добавлять поэлементно значения в еще не созданный массив. Т.е. нужно использовать запись $vegetables2
// Сокращенная новая версия записи массивов используя []
$vegetables2 = ['corn' => 'yellow', 'beet' => 'red', 'carrot' => 'orange'];
// Ввод значений поэлементно.
$vegetables3['corn'] = 'yellow'; // Таким же образом в массив можно добавлять новые элементы с ключами.
// Числовой массив можно создать сокращенной записью. Числовой - когда в ключе нумирация цифрами идет. Ключ инкременируется начиная с нуля.
$dinner = ["Овсянка", "Колбаса", "Суп"];
echo "Я хочу $dinner[0] и $dinner[1]<br>";
$dinner[] = "Вермишель";
echo $dinner[3];
// count($array) - определение размера массива. Пустой массив передаст 0.
$dogs = ["Балонка", "Немецкая"];
echo "Размер массива - " . count($dogs) . " элемента<br>";

foreach ($массив as $ключ => $значение) {} // перебор массива. По сути это цикл, который при каждой итерации записывает в ключ и значение данные массива. Для обозначения ключа и значения допускаются какие угодно имена переменных. Но если до упортреблялись, то перезапишутся значениями из массива. В этом цикле можно получать значение каждого элемента массива. Порядок вывода числового массива будет таким же, каким его вводили, скажем если ключи были 0, 1, 3, 2, то и выводить будет криво. Если нужен точный вывод, лучше использовать цикл for(), но при условии кончено что при создании ввода учитывалось соответствие нумирации массива значению. При таком синтаксисе работа происходит с копией массива. Если нужно изменять в функции значения масива, следует использовать ссылочный синтаксис:
foreach ($массив as $ключ=>&$значение) {здесь можно изменять $значение, при этом будут меняться элементы исходного массива $массив}
foreach ($array as $value) // краткая запись, но в этом случае доступно только значение, ключ не доступен, копируются только значения.

// Изменение значений через жесткую ссылку
$numbers = [100, 313, 605];
foreach ($numbers as &$v) $v++;
echo "Элементы массива: ";
foreach ($numbers as $elt) echo "$elt ";

// чередование классов css
$meal = ["Завтрак" => "Овсянка", "Обед" => "Суп", "Ужин" => "Бекон"];
$row_style = ['even', 'odd'];
$style_index = 0;
echo "<table>";
foreach ($meal as $k => $v) {
	echo '<tr class="' . $row_style[$style_index] . '">';
	echo "<td>$meal[$k]</td><td>$meal[$v]</td></tr>";
	$style_index = 1 - $style_index;
}
echo "</table>";
// for () - тоже перебор массива. Здесь можно получать позицию каждого элемента в числовом массиве.
// чередование классов css при помощи операции по модулю
$dinner = ["Чай", "Славянский", "Круасан"];
$row_style2 = ['even', 'odd'];
echo "<table>";
for ($i = 0; $i < count($dinner); $i++) {
	echo '<tr class="' . $row_style2[$i % 2] . '">';
	echo "<td>Элемент - $i </td><td>$dinner[$i]</td></tr>";
}
echo "</table>";
// При выводе элементов массива в символьной строке с двойными кавычками, ключ нужно писать без кавычек.

// array_key_exists(ключ, массив) - проверяет, присутствует ли в массиве указанный ключ. Если ключ существует, возвращается true.
$vegetables2 = array('corn' => 'yellow',
					'beet' => 'red',
					'carrot' => 'orange',
					'что-то' => 'зеленое');
if (array_key_exists('corn', $vegetables2)) {
	echo "Есть такой элемент! <br>";
}

// in_array(элемент, массив) - проверяет, присутствует ли в массиве указанный элемент. Учитывается регистр букв! Если элемент существует, возвращается true.
if (in_array('red', $vegetables2)) {
	echo "Есть такой элемент! <br>";
}

// array_search(элемент, массив) - возвращает ключ первого найденого элемента.
$dish = array_search('red', $vegetables2);
echo "Вот он - $dish";

// Допустимы операции математические с элементами массива.
// Если в массиве ключ имеет знаки препинания и пробелы, то в строку его нужно в фигурных скобках вставлять, а ключ в одинарных кавычках: {$array['Это ключ...']} - сначала рассчитвывается то, что находится в фигурных скобках.

// unset($array['элемент']) - удаление элемента из массива. Элемент удаляется полностью из массива.
echo "<hr>";
echo $vegetables2['что-то'];
unset($vegetables2['что-то']);
echo $vegetables2['что-то'];

implode('разделитель', $array) // join() склеивает элеметы в символьную строку используя разделитель из одинарных кавычек. Можно в кавычки не ставить разделитель, тогда элементы слипнуться.
// Разделитель можно использовать при создании однотипных элементов верстки, например таблицы, т.е. можно повторять определенные элементы, которые используются в разделителе.
$primer = implode(', ', $vegetables2);
echo $primer;
explode() // разбивает символьную строку на элементы массива. После второй запятой в скобках можно поставить лимит, разобьет только заданное количество элементов
$primer3 = 'yellow, red, orange';
$primer2 = explode(', ', $primer3);
echo $primer2[1];

// Слияние массивов происходит плюсом. Но если ключи одинаковые будут, то у этих ключей значение останется как в первом массиве.

// sort($array) - сортировка элементов массива по алфавиту. Использовать только с числовыми массивами! Функция переписывает все ключи на число от 0 и выше.
asort($array) // сортировка ассоциативного массива без перезаписи ключа. Тоже выстраивает элементы по алфавиту. Соответствие ключей элементам остается.
ksort($array) // сортировка по ключу по алфавиту. Пара ключ-значеие также остаются.
// rsort(), arsort(), krsort() - таже сортировка, только по убыванию.

---------------------------- МНОГОМЕРНЫЕ МАССИВЫ ------------------
$cars = ['BMW' => ['525', '535', 'X5'], 'KIA' => ['RIO', 'CEED', 'STINGER']];
echo $cars['KIA'][1];
// Добавляем новый элемент без индекса. В этом случае он прибавится в конец массива.
$cars['KIA'][] = 'SPORTAGE';
echo $cars['KIA'][3];
// Перебор многомерного массива 1:
foreach ($cars as $key => $value) {
	foreach ($value as $k => $v) {
		echo "Марка: $key------" . ($k + 1) . " Модель: $v<br>";
	}
}
// Перебор многомерного массива 2, но массивы должны быть числовые:
$cars = [['525', '535', 'X5'], ['RIO', 'CEED', 'STINGER']];
for ($i = 0; $i < count($cars); $i++) {
	for ($n = 0; $n < count($cars[$i]); $n++) {
		echo "Марка $i, модель {$cars[$i][$n]}<br>";
	}
}
// Значение многомерного массива вставляется в символьную строку в фигурных скобках {$cars[1][4]}
--------------------------  list() конструкция  --------------------------------
list ($name, $surname, $age) = $list; // Можно было бы конечно каждую переменную загнать в каждое значение массива по отдельности, но так лаконичней
list (, $surname, $age) = $list; // Если массив уже есть и нужно в него передать не все данные, то можно пропустить нужное кол-во переменных, не забывая про запятые с пробелами
--------------------------  МАССИВЫ-КОНСТАНТЫ  ---------------------------------
// Объявляется как обычная константа, а выводится как массив
define ('DOSSIE', ["Anderson" => ["name" => "Thomas", "born" => "1962-03-11"]]);
echo DOSSIE["Anderson"]["name"]; // выведет Томас
--------------------------  СЕРИАЛИЗАЦИЯ  --------------------------------------
// массив можно запаковать в строку, и в нужном месте распаковать.
serialize() // Запакует указанный массива
unserialize() // Распакует в точности как и был. Можно так любые объекты делать, но все же используется с массивами.

**************************  ООП  ***********************5988********************
--------------------------  КЛАСС СВОЙСТВА  ------------------------------------
// Рекомендация 1 класс = 1 файл. В этом файле описываем только класс и ничего более.
// Объявляем класс через class. В имени принято использовать заглавную букву, если из двух слов состоит, то слитно и второе слово тоже с заглавной. Можно начинать с подчеркивания либо буквы, внутри можно использовать и подчеркивание и цифры. Есть определенные именна, которые зарезервированы
class Car
{
  public $color;  // Свойство без значений
  public $wheels = 4; // Свойство со значением по умолчанию
}
// Объект класса (переменная класса по другому) имеет члены: - свойства - значения различных типов, и - методы - функции, операции, которые могут быть проведены с набором свойств. Эти члены относятся к объекту, хотя создаются в классе.
// У свойства обязательно должен быть один из 3-х модификаторов. Модификатор public имеет синоним из 4-й версии var - не используй, он устарел.
// Класс отдельно пишем в файле, этот файл подключаем в коде. Класс создается отдельно, а объект создается отдельно, как в функции - описание функции и ее вызов разне вещи. И теперь чтобы пользоваться классом, нужно создать объект этого класса через new
$car1 = new Car(); // Можно не заносить в пеерменную чтобы создать объект. Теперь объект $car1 хранит в себе все данные класса (значения свойств, методов, если они есть).
// Новое свойство объекту класса можно добавить на лету - динамические свойства. Но это не рекомендуется. Только в некоторых случаях. Поскольку класс не предполагает добавление новых свойств и нет методов для работы с ними. Кроме этого можно ошибиться в написании имени свойства и задать два свойства вместо одного (color - colour). Так же можно переопределять имеющиеся свойства таким же образом вне класса.
$car1->color = 'черный'; // Добавление значения к имеющемуся свойству. Так же переопределяется.
$car1->brand = 'volvo'; // Динамическое добавление нового свойства
// Стрелка показывает с каким объектом работаем (их можно создавать много). Стрелка показывает с каким свойством работаем. $ ставится только перед объектом. Чтобы просто вывести значения свойств на экран используем в фигурных скобках.
  echo "<h3>О момем авто:</h3>
  Марка: {$car1->brand}<br>
  Цвет: {$car1->color}<br>
  Кол-во колес: {$car1->wheels}<br>";
// Тело класса можно разрывать с использованием дескрипторов. Но это ни к чему
--------------------------  МЕТОД  ---------------------------------------------
// Имя метода принято начинать с мальенькой буквы, а последующие слова с большой, слитно. Модификаторы не обязательны, по умолчанию - публичный. Так же не рекомендуется давать такое же название как у класса. Чтобы не писать каждый раз вывод на экран значений свойств при создании нового объекта, можно и нужно этот вывод занести в метод:
class Car
{
  public $color;
  public $wheels = 4;

  public function getCarInfo() { // Создан метод getCarInfo()
    return "<h3>О момем авто:</h3>
    Цвет: {$this->color}<br>
    Кол-во колес: {$this->wheels}<br>";
  }
}
$car1 = new Car();
$car1->color = 'черный';
// $this - эта переменная всегда существует внутри методов. Она помогает добраться до членов класса. Если в индексном файле мы писали сначала с каким объектом работаем $car1->color (перед стрелкой), то в методе мы через $this пишем, что работаем со свойством текущего класса, точнее со свойством текущего объекта в конечном виде. Теперь вместо длинного кода в индексном файле мы пишем более короткий вызов:
echo $car1->getCarInfo(); // Теперь мы обращаемся не к свойсту, а к методу, метод в свою очередь обращается к свойствам.
// Анахронизм 4-й версии. Когда не было конструктора, создавали метод с тем же названием что и класс. Если нет конструктора в классе, то при создании метода с аналогичным классу именем, этот метод становится конструктором, но выводится замечание. Лучше не использовать, в дальнейшем это удалится. Если значение возвращается, называется геттер, если значение устанавливается, называется сеттер.
--------------------------  МОДИФИКАТОРЫ - ОБЛАСТИ ВИДИМОСТИ  ------------------
// В PHP 4 нужно было var ставить перед свойсвами, означало public, друхих модификаторов не было. Для методов такого не было.
// У свойств и методов одни и теже модификаторы и имеют одно и тоже значение.
public // Доступный - в класе доступен, во всех наследниках доступен, вне класса тоже доступен.
protected // Защищенный - доступен только в том классе где объявлен и во всех классах наследниках. Вне класса не доступен.
private // Закрытый, приватный - доступен только внутри класса! Ни в наследниках, ни вне класса он не доступен.
// Советует побольше делать свойства приватными, методы в основном публичными (только служебные приват) - но он ставит либо баб, либо прот.
--------------------------  СТАТИЧЕСКИЕ МЕТОДЫ И СВОЙСТВА  ---------863495------
// После модификатора свойства или метода нужно добавить ключ static, тогда их можно использовать в контексте класса. Это нужно если нет необходимости создавать объект, но нужны вычисления внутри класса. К примеру если пишем калькулятор. Говорят КлассоОриентированное Программирование.
self::$countCar++; // обращение к статике в классе Оператор разрешения области видимости (Paamayim Nekudotayim - на иврите означает двойное двоеточие). Внутри класса вместо селф допустимо написать имя текущего класса, будет работать. Но не делай так! Иначе при смене имени класса, придется еще и статику переименовывать.
echo Car::$countCar; // Вызов статики через имя класса в файле.
// $this не доступен в статике.
--------------------------  КОНСТАНТА  -----------------------------------------
// Имя с заглавными буквами, если несколько слов, то через нижнее подчеркувание. Константа тоже принадлежит классу. Работа с ней через self. По умолчанию константа public. C версией 7.1 можно ставить модификаторы для констант, если нужно.
class // встроенная конатсанта - echo Car::class; // Выведет имя класса.
class Car // Весь остальной код выше, убрал свойства.
{
  public static $countCar = 0; // Добавили статику
  const TEST_CAR = 'Прототип'; // Добавили константу

  function __construct(...) {
    self::$countCar++; // В конструкторе обращаемся к статике и делаем итерацию, если будет вызван объект.
  }
  function getCount() {
    return self::$countCar; // Метод вернет счетчки.
  }

  public function getPrototypeInfo() {
    return "Марка: " . self::TEST_CAR . "<br>"; // Работа с константой в методе
  }
}
// Выводим в индексном файле
echo $car1->getCarInfo(); // Создание объекта
echo Car::getCount(); // Обращение к методу счетчика и вывод
echo $car1->getPrototypeInfo(); // Обращение к методу где есть константа
echo Car::TEST_CAR; // Обращение к константе (так же как и к статике)
// Константу можно переопределить в дочернем классе. Просто в свойстве если напишем такую же константу с другим значением. А вот внутри класса переопределять константу нельзя.
--------------------------  КОНСТРУКТОР  --------------576987-------------------
// Так же мы можем автоматизировать ввод значений в свойства объекта класса. Для этого используем конструктор. Это та же функция, в которой мы прописываем в скобках переменные. В нем тоже можно вносить значения по умолчанию. В эти переменные в скобках попадут значения, которые ты введешь в скобки при создании объекта. Магия, или магический метод. Магические методы рекомендуется писать перед своими методами.
// Имена аргументов конструктора для удобства присваивают такие же как у свойств, хотя можно другие.
class Car
{
  public $color;
  public $wheels = 4;

  function __construct($color = 'красный', $wheels) { // в скобках конструктора прописываем переменные
    $this->color = $color; // делаем связь прописанных переменных со свойствами
    $this->wheels = $wheels;
  }

  public function getCarInfo() {
    return "<h3>О момем авто:</h3>
    Цвет: {$this->color}<br>
    Кол-во колес: {$this->wheels}<br>";
  }
}
$car1 = new Car('черный', 4, 180, 'volvo'); // Значения идут в конструктор, а от туда в свойства объекта класса
echo $car1->getCarInfo();
// Последние две строчки - это код в индексном файле. Класс разбух, но зато при создании множества классов не придется прописывать один и тот же код. Конструктор при необходимости можно вызвать вручную $scar1->__construct($color = 'красный', $wheels) - но нет смысла
--------------------------  ДЕСТРУКТОР  --------------893245--------------------
// Если конструктор автоматически запускается при создании объекта, то деструктор срабатывает при уничтожении объекта. Когда осовбождаются все ссылки на объект, объект удаляется из памяти, при этом срабатывает деструктор, точнее перед удалением объекта. Объекты удаляются в свободном порядке, так что сложную логику через него не стоит делать. Подходит при работе с бд, можно закрывать соединение им, можно закрывать файлы.
function __destruct() {}
--------------------------  НАСЛЕДОВАНИЕ  --------------------------------------
// Создается шаблонный класс, в котором имеются все свойства и методы свойственные разным объектам. Например цена и наименование товара. А вот скажем частота процессора будет добавляться в новом классе, а количество страниц для книги еще в одном классе. Но оба новых класса будут наследовать от родиля цену и наименование.
class Product{ // Это шаблонный класс продукта со свойствами и конструктором
  public $name;
  public $price;

  function __construct($name, $price)
  {
    $this->name = $name;
    $this->price = $price;
  }
  function getProduct(){
    return "<hr><b>О товаре:</b><br>
    Наименование: {$this->name}<br>
    Цена: {$this->price}<br>";}}
// Теперь если нужен новый товар, создаем новый класс, котоый пока просто дублирует полностью шаблон. ПО сути все что в шаблоне, сейчас будет в новом классе один в один, только название класса другое.
class NotebookProduct extends Product{
  function __construct(){}}
// Но нам нужно создать новые свойства и переписать конструктор. Необходимо продублировать свойства в родителе и связь свойства с объектом.
class NotebookProduct extends Product{
  public $cpu; // Создаем одно свойства
  function __construct($name, $price, $cpu){ // Тут продублировали и добавили новую переменную
    $this->name = $name; // Дубль
    $this->price = $price; // Дубль
    $this->cpu = $cpu;}} // Новое
// Внимание! Конструктора этот, дочерний, переопреписывает Параметры родителя! Чтобы избавиться от дублей в коде, нужно использовать parent
function __construct($name, $price, $cpu) { // Здесь прописываем все параметры и родителя, и новые
  parent::__construct($name, $price); // Вызываем родительский конструктор, обязательно вписываем параметры родителя
  $this->cpu = $cpu; } // А тут ссылаемся на новое свойство в этом классе.
// Так же дописываем метод вывода значений, который тоже перезаписывает значения родителя.
function getProduct(){
  $out = parent::getProduct(); // Берем родительский метод, перезаписываем, вставляем в переменную для дальнейших действий
  $out .= "Процессор: {$this->cpu}<br>"; // Тут добавляем вывод процессора
  return $out;}
// Язык позволяет делать цепочку наследования. Т.е. сначала шаблон, шаблон наследуешь в другом классе, в третьем классе наследуешь второй класс и тд. Множественные наследования не доступны.
--------------------------  АБСТРАКТНЫЙ КЛАСС - МЕТОД  --------86245------------
// Задача этого класса запретить создавать объект этого класса. Это логично, если создается базавый класс, шаблон, члены которого будут наследоваться. Но наследовать класс можно.
abstract class Product {}
// Абстрактный метод не может содержать тело (то что в фиг. скобках), он несет описательный характер.
// Абстрактный метод нельзя создавать в обычном классе, только в абстрактном.
abstract public function addProduct($name, $price); // Т.е. неикаких ф. скобок, только точка с запятой после скобок.
// Абстрактный метод обязательно должен быть определен в дочернем классе. Его можно просто объявить без реализации.
function addProduct($name, $price) {}
// Это что-то вроде тех задания. Если работают несколько человек, или сам, создается абстрактный метод. И код не будет работать, пока метод не объявится в дочернем, тогда его нужно будет просто объявить и уже дальше реализовывать его.
// Нужно следить за областью видимости. Если у абстрактного метода стоит паблик, то у дочернего нельзя объявлять жесче модификатор, только ниже.
// Количество параметров в скобках тоже должно совпадать. Но их можно добавить, сделав необязательными, просто в скобках добавить параметр равный нулю $a = 0
--------------------------  ИНТЕРФЕЙСЫ  ----------------------------------------
// Говорит что ниразу еще не использовал и часто интерфейсы используют не по делу
// Это те же классы, но без реализации. Вместо слова класс используется слово интерфейс. Наследовать можно кучу через запятую.
// Все методы интерфейса должны быть публичными, чтобы в дочерних были видны.
// Все методы должны быть без тела - без реализации, как абстрактные методы.
// Тоже создается Отдельный файл и в отдельной папке. Называть нужно с большой или маленькой буквы i. В нем можно создавать свойства, константы, методы.
interface I3D {} // Объевление интерфейса
class BookProduct extends Product implements I3D {} // Подключение интерфейса в классе
// Если в интерфейсе есть метод, его тут же нужно реализовывать в классе, где подключается, как абстрактный метод.
// Константу определенную в интерфейсе нельзя переопределить в дочерних классах.
// Интерфейсы удобно применять вместе с контролем типов. Как вариант использовать интерфейс для постановки техзадания.
--------------------------  ИНДИКАЦИЯ ОШИБОК - ИСКЛЮЧЕНИЯ  ---------------------
function __construct($ingredients) {
  if (! is_array($ingredients)) {
    throw new Exception('$ingredients должен быть массивом'); // см ниже
  }
  $this->ingredients = $ingredients;
}
// Создается новый объект типа Exeption, в которой передается символьная строка, в которой мы описываем причину сбоя, этот объект передается языковой конструкции throw с целью прервать работу интерпретатора.
// Если подается не тот тип, то выводится ошибка состоящая из двух частей:
// Fatal error: Uncaught Exception: $ingredients должен быть массивом in C:\OSPanel\domains\php\classes\Entree.php:10
// Говорит о том, что в строке 10 соответствующего файла, было сгенерировано исключение. А поскольку доп кода нет, то это исключение неперехватываемое - Uncaught Exception. Эта ошибка моментально прерывает работу программы.
// Stack trace: #0 C:\OSPanel\domains\php\php_david_sklar.php(14): Entree->__construct('Glass of milk', 'milk') #1 {main} thrown in C:\OSPanel\domains\php\classes\Entree.php on line 10
// Вторая составляющая - трассировка стека - перечень всех функций, которые были активны на момент ошибки. Строка {main}  в  трассировке стека представляет первый уровень выполнения программы прежде остального. Этот уро­вень всегда находится в нижней части любой трассировки стека.

-------------  Это по книге ООП
// С каждым типом данных логически связанны данные двух видов:
// 1. Набор битов, представляющей значение переменной.
// 2. Набор функций и операторов, предназначенный для обработки этих битов.
// Класс можно рассматривать как тип определенной переменной.
// Так же как может сущетвовать много переменных одного типа, не связанных между собой, может быть множество объектов одного класса с различными свойствами:
| Тип > переменная/переменная/переменная/переменная/переменная/....
|Класс> объект/объект/объект/объект/объект/объект/объект/объект/.....
// Так же как у типа, у объекта класса набор свойств (данные) отличаются, а методы (операторы) одинаковые.
// Если int рассмотреть как класс, то у переменной одно только свойство будет - целое значение. А набор методов это операции + - / *
class MathComplex { // Описываем класс без конструктора
	public $re, $im;  // Свойства: действительная и мнимая части. Свойства можно без цифр определять, через запятую, либо на новой строке с значением по умолчанию public $a = 10; Кроме этого в свойствах можно использовать математические операторы + и конкотенацию
	function add($re, $im) { // Метод: добавить число к текущему значению. Число задается своей действительной и мнимой частью.
		$this->re += $re;
		$this->im += $im;
	}
}
$obj = new MathComplex; // Создание нового объекта класса MathComplex.
$obj->re = 6; // Присваиваем значение свойству re. Если значение было по умолчанию, то оно перезапишется.
$obj->im = 101; // Присваиваем значение свойству im
echo $obj->re; // Выводим значение свойства re объекта $obj
echo "{$obj->re}<br>"; // Внутри кавычек свойства выводим в фигурных скобках
$obj->pe = 200;








// Имя класса - экземпляр класса
function intager(int $i) {
	echo $i;
}
intager(5); // Если передать строку, будет ошибка, программа прекратит работу, если не стоит улавливатель ошибок. Если передать число с запятой, уберет все, что после запятой.
// Возвращаемую функцией переменную тоже можно проверить на определенный тип. Я так понял работает только на вовзращаяемое значение. Если вместо возврата делать вывод на экран, выдаст ошибку.
function check($ch): float {
	$ch /= 5;
	return $ch;
}



**************************  РАБОТА С ФОРМАМИ  *************26547****************
  // Все данные формы передаются в несколько массивов
$_REQUEST // глобальный массив, в него попадают имена полей в качестве ключа и значение введенное пользователем.
$_GET // Гет параметры - массив содержит гет параметры $_GET['login']
$_POST // Данные пришедшие методом POST
$_COOKIE // Все куки которые прислал браузер
$_SERVER // содержит переменные окружения, переданные сервером
// В этом скрипте сразу и обработчик и форма в одном месте.
<?php if (!isset($_REQUEST['doGO'])) {?> // Если кнопка не нажималась, выводится форма. А если нажималась, она бы записалась в массив.
  <form action="<?$_SERVER['SCRIPT_NAME']?>"> // Этот прием дает возможность использовать и обработчик и форму в одном скрипте.
    Логин: <input type="text" name="login" value=""><br>
    Пароль: <input type="password" name="password" value=""><br>
    <input type="submit" name="doGO" value="Нажмите кнопку!">
  </form>
<?php } else {
  if ($_REQUEST['login'] == "root" && $_REQUEST['password'] == "Z10N0101") {  // Проверка введенных данных.
    echo "Доступ открыт для пользователя {$_REQUEST['login']}";
    system("rundll32.exe user32.dll,LockWorkStation");  // Блокирует текущего пользователя, выводит пароль, если установлен в компе.
  } else {
    echo "Доступ закрыт!";
  }
}?>
// Если встречаются в форме множественный выбор (имя там одно), то создается двумерный массив $_REQUEST['multiple'][0], $_REQUEST['multiple'][1]
// В имени полей можно использовать название масива с ключем (КЛЮЧ БЕЗ КАВЫЧЕК!)
  <input type="radio" name="Data[city]" value="Moscow">Москва<br>
$_REQUEST['Data']['city'] // Вывод значений
// У радиокнопок, перед каждой кнопкой нужно выводит скрытое поле с тем же именем что и инпуты и в валу ставим нужное значение, например 0. Если пользователь не выберет ни одной кнопки, то придут нули по каждому полю.
  <input type="hidden" name="known[PHP]" value="0">
  <input type="checkbox" name="known[PHP]" value="1">PHP
--------------------------  ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ  ------------------------------
$_SERVER['QUERY_STRING'] // передает в строку данные из url после вопроса. Можно было бы использоавать при работе с формами, но в php встроены другие инструменты.
$_SERVER['REMOTE_ADDR'] // ip адрес пользователя
$_SERVER['HTTP_USER_AGENT'] // Браузер пользователя
// Порядок трансляции переменных GET-POST-COOKIE (GPC) - если транслируется одна и таже переменная, то она будет перезаписана в этом порядке
--------------------------  КУКИ  ----------------------------------------------
$_COOKIES // Все куки попадают в этот массив.

**************************  ФУНКЦИИ  *****************795324********************
// Инициализровать (определить) функцию можно в любом месте кода, интерпритатор читает страницу целиком и выводит функцию вне зависимости от ее размещения.
function say_hallo() { // Создание функции
	echo "<p>Привет, Мир!</p>";
}
say_hallo (); // Вывод функции
// Имя функции регистронезависимо, но должно быть уникальным. Но можно давать такие же как и переменным.
// Определенную функцию нельзя переопределить
// Аргументы можно передавать внутрь функции при вызове функции. Но можно вовсе не использовать аргументы. Аргумент становится обязательным при вызове функции, если нет аргумента по умолчанию. Поумолчанию нельзя вставлять переменные, только литералы прописанные внутри функции. Можно через запятую выводить несколько аргументов. Если какие-то стоят по умолчанию, то их нужно использовать в конце аргументов.
function page_header2($title, $text = 'Сегодня поговорим о аргументах функции.', $color2 = 'ffffff') {
	echo "<h1>$title</h1>";
	echo "<p>$text</p>";
	echo "Цвет фона - $color2<br>";
}
page_header2('Аргументы, часть 2', 'Аргументов может быть несколько');
// Функция может возвращать значение через return. Без возврата будет называться процедурой и возвращать будет null Возвратов можно ставить несколько через условия. Также одну функцию можно использовать в другой функции.
// Вовращать может любые объекты любых размеров и с огромной скоростью. Несколько значений не выводит, но можно в масив или через усл.
function restaurant_chek($meal, $tax, $tip) {
	$tax_amount = $meal * ($tax / 100);
	$tip_amount = $tip * ($tip / 100);
	$total_amount = $tax_amount + $tip_amount + $meal;
	return $total_amount;
}
function payment_method($cash_on_hand, $amount) {
	if ($amount > $cash_on_hand) {
		return 'credit card';
	} else {
		return 'cash';
	}
}
$a = restaurant_chek(15, 8, 15);
$pay_with = payment_method(20, $a);
echo "I will pay with $pay_with";
// Через условия можно сделать, чтобы функция возвращала истину или ложь
function can_pay_cash($cash_on_hand, $amount) {
	if ($amount > $cash_on_hand) {
		return false;
	}	else {
		return true;
	}
}
// Объединение вызова функции с проверкой в условии.
function check_1($a, $b) {
	if ($b > $a) {
		return false;
	} else {
		return $a;
	}
}
if ($c = check_1(8,10)) {
	echo "Ваше число $c";
} else {
	echo "Нет числа";
}
// В аргументы можно передвать переменные, тогда функция будет работать с копией переменной. Но если в аргументе при инициализации функции поставить амперсанд, то функция уже работает не со ссылкой, а со значением и может менять в теле исходное значение.
function increment(&$a) {}
--------------------------  ПЕРЕМЕННОЕ ЧИСЛО ПАРАМЕТРОВ  -----------------------
// При вызове функции можно указывать больше параметров, чем задано в списке аргументов. Лишнее игнорируется, а вот если меньше задавать, будет ошибка. К таким параметрам есть доступ через функции:
func_num_args() // Вовращает общее число аргументов при вызове функции
func_get_arg($num) // Вовращает значение аргумента с номером $num, заданным при вызове функции
func_get_args() // Чаще всего лучше применять эту функц. Вовращает список всех аргументов
  function myecho() {
    for ($i = 0; $i < func_num_args(); $i++) {
      echo func_get_arg($i)."<br />\n"; // выводим элемент
    }
  }
// Переписали
  function myecho()
  {
    foreach (func_get_args() as $v) {
      echo "$v<br />\n"; // выводим элемент
    }
  }
  myecho("Меркурий", "Венера", "Земля", "Марс"); // отображаем строки одну под другой
// Но есть другой способ - многоточие
  function myecho(...$planets)
  {
    foreach ($planets as $v) {
      echo "$v<br>\n"; // выводим элемент
    }
  }
  myecho("Меркурий", "Венера", "Земля", "Марс"); // отображаем строки одну под другой
// Можно использовать для развертывания массива
function toomanyargs($fst, $snd, $thd, $fth)
{
  echo "Первый параметр: $fst<br />";
  echo "Второй параметр: $snd<br />";
  echo "Третий параметр: $thd<br />";
  echo "Четвертый параметр: $fth<br />";
}
$planets = ["Меркурий", "Венера", "Земля", "Марс"];
toomanyargs(...$planets); // отображаем строки одну под другой
--------------------------  ТИПЫ АРГУМЕНТОВ И ВОЗВР значения  ------------------
function sum(int $fst, int $snd) : int // Через двоеточие определяем возвращаемое значение
{
  return $fst + $snd;
}
echo sum(2, 2);
echo sum(2.5, 2.5); // Fatal Error в PHP < 7, Exception TypeError в PHP >=7
// Чтобы язык эмулировал режим жесткой типизации (и требовал указаный тип) нужно его включить
declare(strict_types=1); // Пишется перед определением функции
--------------------------  ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ  -----------------------------
// Внутри функции переменная является локальной. Переменная функция может (но не желательно) называться такжек как и любая переменная вне функции, но значения не будут приравниваться или влиять друг на друга.
$m = 100;
function summ($m) {
	$m += 777;
	echo "Выводим функцию ";
	echo $m; // Локальная переменная называется также как и переменная вне функции, но это не влияет на нее.
}
echo "Выводим переменную - $m<br>"; // Выведет 100
summ(23); // Выведет 800
// $GLOBALS['m'] Автоглобальная переменная, этот вариант более предпочтителен, с ним код читается лучше. Также внутри фнукции можно изменять значения глобального массива. Можно использовать не только в массиве, но и в любом месте кода. По сути это моссив. Но его нельзя присвоить переменной. Можно через него создавать новые переменные, через ансет переменные будут удаляться.
function summ_2($m) {
	echo "Переменная вне функции и до ее изменения " . $GLOBALS['m'] . "<br>";
	echo "А вот переданная переменная - $m<br>";
	$GLOBALS['m'] = 500;
}
summ_2(30);
echo "А это уже измененная глобальная переменная $m";
// global - второй вариант. Также можно изменять внутри функции глобальную переменную. Можно сразу применять к неск. переменн. - global $dinner, $lunch, $breakfast;
echo "Это измененная переменная впрошый раз - $m<br>";
function summ_3() {
	global $m; // Ссылка на глобальную переменную
	$m = 999;
}
summ_3();
echo "Опять изменили переменную - $m<br>";
echo "<hr>";
--------------------------  СТАТИЧЕСКИЕ ПЕРЕМЕННЫЕ  ----------------------------
function selfcount()
{
  static $count = 0; // Запоминается значение
  $count++; // Меняется значение и запоминается уже измененное
  echo $count;
}
for ($i = 0; $i < 5; $i++) selfcount(); // Выведет 12345
--------------------------  АНОНИМНЫЕ ФУНКЦИИ  ---------------------------------
// Функция без измени
$myecho = function (...$str)
{
  foreach ($str as $v) {
    echo "$v<br />\n"; // выводим элемент
  }
};
$myecho("Меркурий", "Венера", "Земля", "Марс"); // Вызов функции
--------------------------  ОТЛАДОЧНЫЕ ФУНКЦИИ  --------------------------------
print_r($a) // Выводит отладочное представление переменной. Если в скобках после переменной дописать ($a, $return = true), не печатает в браузер ничего, но возвращает отладочное предст. в виде строки. Если ($a, 1) - выведет в столбик данные. Можно сделать функцию для всего кода, просто туда подставлять переменные, чтобы длинный код каждый раз не набирать.
  function debug($data) {
    echo "<pre>" . print_r($data, 1) . "</pre>";
  }
var_dump($a) // Тоже выводит, но прописывает тип переменной
var_export($a) // Похожа на print_r($a), но значение которое она выводит можно использовать как кусок php, т.е. сразу брать то что выводится, и вставлять в файл и этот код будет работать.
  // Причем у апострофов ставится обратный слэш. Так же выводит для объектов описания всех свойств, в том числе закрытых. Мы получаем программу, которая пишет другие программы.
  class SomeClass
  {
    private $x = 100;
  }
  $a = array(1, array ("Programs hacking programs. Why?", "д'Артеньян"));
  echo "<pre>"; var_export($a); echo "</pre>";
  $obj = new SomeClass();
  echo "<pre>"; var_export($obj); echo "</pre>";


**************************  ВСТРОЕННЫЕ ФУНКЦИИ  *********7548632****************
--------------------------  СТРОКОВЫЕ  -----------------------------------------
strlen() // подсчитывает кол-во симоволов в строке если цифры, знаки препинания, пробел и латиница. А вот русские считает как кол-во байт (если в конфигурации установлено mbstring.func_overload на 0), потому что латиница кодируется одним байтом, а кириллица двумя.
  $_post = ' 4569815 ';
  if (strlen(trim($_post)) != 6) {
  	echo "Чувак, в нашем коде 6 символов, а не как ты ввел :)";}

mb_strlen() // считает символы посимвольно, не байтами.

strval($a) // Перевод в строку

trim() // Убирает пробелы с обоих концов, причем все включая перевод строки, таб, перевод каретки и тд. Первый аргумент нужная строка, второй необязательный - строка в которой перечислены те пробелы, которые нужно удалить.
$_post = ' 4569815 ';
if (strlen(trim($_post)) != 6) {
	echo "Чувак, в нашем коде 6 символов, а не как ты ввел :)";}
ltrim() // Концевые не трогает, старайся не применять
chop() // Удаляет только концевые. rtrim() - второе название

strpos($a, $b) // ищет в строке а последовательность символов б, и возвращает позицию. Третим аргументом $from = 2 можно задать позицию с которой начинать. Если не находит, вернет ложь.
strrpos($a, $b [, $from = 0]) // Ищет последнюю позицию в которой встречается подстрока б
// strcmp(a,b) - сравнивает аргументы в лексикографическом порядке, не преобразуя число в строку. Если а больше б то возвращает положительное число, иначе отрицательное. Символы сравниваются последовательно один за другим, если по ходу одно число больше другого на одном уровне, то все число больше. Количество символов в строке не имеет значения. Если равны, функция возвращает 0. Если без функции сравнивать символьные строки там другой расклад. Буквы сравнивает по порядку расположения в алфавите.
$x = strcmp('6 штук', 55); // 6 больше 5, дальше не смотрит символы.
if ($x > 0) {
	echo 'Первый больше второго';
} else {
	echo 'Второй больше первого';
}
echo '<hr>';
if ('6 штук' > 55) { // Интерпритатор преобразует первую переменную в число 6 и сравнивает с 55
	echo 'Первый больше второго';
} else {
	echo 'Второй больше первого';
}

strcasecmp(a,b) // если сравниваемые строки одинаковы, возвращается 0, регистр не учитывается
$_mail1 = 'info@guzun.ru';
if (strcasecmp($_mail1, 'info@GUZUN.ru') == 0) {
	echo "Почта идентична, ну почти, функция то регистр отключает";
}

substr(a,b,c) // обрезка символьной строки по кол-ви байт, точнее возвращает отрезок. У кириллицы на одну букву выводится больше одного байта и какой-то вопрос в конце выводится
$_POST = 'Текст тут какой-то который будет обрезаться в этой функции';
// Извлечь первые 30 байт из переменной
echo substr($_POST, 0, 30).'...';
echo '<hr>';
// Первый аргумент переменная, второй аргумент показывает с какого сивола вести отсчет. Если 0 то с начала. Если минусовое значение, то беретпоследние цифры в конце строки. Последний аргумент можно не использвать, дойдет до начала строки.
$card = '1235-4561-5879-5468';
print "Карта: ХХ";
print substr($card,-4);
print '<hr>';

str_replace(a,b,c [, $count]) // замена символов а на символы из переменной b в переменной с (с учетом регистра). Фигурные скобки я так понял для удобства, работает и без них. Последний параметр необязательный - можно указать кол-во замен. Работает так же с массивами.
$dog = 'Собака {Колли} замечательное животное';
$dog_repl = 'Немецкая овчарка';
echo str_replace('{Колли}', $dog_repl, $dog);
str_ireplace(a,b,c [, $count]) // Тоже самое только без учета регистра
substr_replace ($text, $to, $start, $len) // Замена значения в строке значением то начиная со старт, длина необязательна.

**************************  SQL  *********3587632*******************************
// Язык программирования - структурированный язык запросов
// В таблице может не быть строк, но должен быть хотя бы один столбец.
// Реляционные базы данных - таблицы которые могут быть связаны между собой.
// Первичный ключ - primary key - столбец, в строках которого не повторяющееся значение. Естественный, суррогатный - лучше использовать суррогатный, отдельный столбец id, а не привязываться к имеющимся данным в таблице.
// Внешний или вторичный ключ - foreign key - к примеру таблица товара с первичным ключем, а вторичный ключ будет соответствовать первичному ключу таблицы с категориями, соответствующей категории.
CREATE DATABASE wet; // создание бд wet
SHOW DATABASES; // узнать имея существующих бд. Этой же коммандой можно проверить, создалась ли базза.
DROP DATABASE wet; // удаление базы данных
CREATE DATABASE wet DEFAULT CHARACTER SET utf-8; // Создание бд с конкретной кодировкой.
USE test; // Выбор базы данных
SHOW TABLES; // Покажет таблицы в текущей бд

--------------------------  ТИПЫ ПОЛЕЙ  ----------------------------------------





// abs() - выводит абсолютное значение.
$value = 5.0000000000007;
echo abs($value);
echo '<hr>';
count($массив) // sizeof() - смноним // определение размера массива. Пустой массив передаст 0.
// isset() - проверяет установлена ли переменная
// dechex() — Переводит число из десятичной системы счисления в шестнадцатеричную
// printf() - правило форматирования %.2f заменяется выражением после запятой. f значит число с плавающей точкой, .2 значит, что нужно после запятой только 2 символа выводить. .2 не обязательный элемент, а вот f указ. число с плав. точкой, d - десятичное число, s - строка.
 $prise = 5; $tax = 0.075;
 printf('Стоимость заказа составляет %.2f руб.', $prise * (1 + $tax));
 echo '<hr>';
// printf() - %06d означет сколько нулей добавить к началу символа, 6 означет что добавлять толькое если символов меньше шести. Если 6 или больше символов, то выводит полное исходное число.
$zip = '45820';
$month = 2;
$day = 6;
$year = 2007;
printf("Индекс - %06d и дата %02d/%02d/%d", $zip, $day, $month, $year);
echo '<hr>';
// printf() - если стоит +, то выводит истинный знак символа. + у любого числа по умолчанию.
$min = -40;
$max = 40;
printf("Комп может работь при температуре от %+d до %+d градусов.", $min, $max);

// strtoupper(), strtolower() - смена регистра букв, но на буке чет не работает с кириллицей, нужно смотреть локаль.
echo strtolower('<p>DOwn - ');
print strtoupper('UUpp</p>');
echo '<hr>';

// ucwords() - делает первые буквы всех слов заглавными, тоже проблема с русскими и если тэги в начале, то они их воспринимает, но тэг идет как первая буква
echo ucwords(strtolower("EVGENIY GUZUN"));
echo '<hr>';




******************************  Тесты СКЛЯР  ***********************************
// Глава 2
// Задание 3
$haburger = 4.95;
$milk_coctale = 1.95;
$coca_colla = 0.85;

$tax_rate = 0.075;
$tip_rate = 0.16;
$food = (2 * $haburger) + $milk_coctale + $coca_colla;
$tax = $tax_rate * $food;
$tip = $tip_rate * $food;
$order = $tax + $food;
printf("%d %-9s at \$%.2f each: \$%5.2f\n", 2, 'Hamburger', $haburger, $haburger * 2);
printf("%d %-9s at \$%.2f each: \$%5.2f\n", 1, 'Shake', $milk_coctale, $milk_coctale);
printf("%d %-9s at \$%.2f each: \$%5.2f\n", 1, 'Coca_colla', $coca_colla, $coca_colla);
printf("%25s: \$%5.2f\n", 'Food total', $food);
printf("%25s: \$%5.2f\n", 'Total order', $tip + $order);

// Задание 4
$first_name = "Evgen";
$last_name = "Guzun";
$fio = $first_name . ' ' . $last_name;
echo $fio;
echo ' - '.strlen($fio);
print '<hr>';

// Задание 5
$n = 1; $p = 2;
echo "$n, $p\n";
$n++; $p *= 2;
echo "$n, $p\n";
$n++; $p *= 2;
echo "$n, $p\n";
$n++; $p *= 2;
echo "$n, $p\n";
$n++; $p *= 2;
echo "$n, $p\n";
print '<hr>';

// Глава 3
// Задание 3 - перевод фаренгейта в цельсия
$i = -50;
while($i <= 50) {
	$c = ($i-32)*(5/9);
	printf("%d F = %d C<br>", $i, $c);
	$i += 5;
}
echo "<hr>";
// Задание 4 - то же, только цикл другой
for ($n = -50; $n <= 50; $n += 5) {
	$m = ($n - 32) * (5 / 9);
	printf("%d F = %d C<br>", $n, $m);
}

// Глава 4
// Задание 1 - население городов в массиве
$population = ['Нью-Йорк' => 8175133,
				'Лос-Анджелес, шт. Калифорния' => 3792621,
				'Чикаго, шт. Иллинойс' => 2695598,
				'Хьюстон, шт. Техас' => 2100263,
				'Филадельфия, шт. Пенсильвания' => 1526006,
				'Феникс, шт. Аризона' => 1445632,
				'Сан-Антонио, шт. Техас' => 1327407,
				'Сан-Диего, шт. Калифорния' => 1307402,
				'Даллас, шт. Техас' => 1197816,
				'Сан-Хосе, шт. Калифорния' => 945942];
echo "Население городов Америки:<br>";
echo "<table>";
foreach ($population as $k => $v) {
	echo "<tr><td>$k</td><td>($v человек)</td></tr>";
}
echo "</table>";
$total_population = 0;
foreach ($population as $key => $value) {
	$total_population += $value;
}
echo "Общая численность населения этих городов - $total_population.<hr>";
// Задание 2 - Упорядочивание
asort ($population);
echo "Упорядочивание по населению:";
echo "<table>";
foreach ($population as $k => $v) {
	echo "<tr><td>$k</td><td>($v человек)</td></tr>";
}
echo "</table>";
echo "<hr>";
ksort ($population);
echo "Упорядочивание по городам:\n";
echo "<table>\n";
foreach ($population as $k => $v) {
	echo "<tr><td>$k</td><td>($v человек)</td></tr>\n";
}
echo "</table>\n";
echo "<hr>";
// Задание 3 - добавить пересчет населения в штатах.
echo "<table><tr><th>Город</th><th>Штат</th><th>Население</th></tr>";
$census = [['Нью-Йорк', 'шт. Нью-Йорк', 8175133],
			['Лос-Анджелес', 'шт. Калифорния', 3792621],
			['Чикаго', 'шт. Иллинойс', 2695598],
			['Хьюстон', 'шт. Техас', 2100263],
			['Филадельфия', 'шт. Пенсильвания', 1526006],
			['Феникс', 'шт. Аризона', 1445632],
			['Сан-Антонио', 'шт. Техас', 1327407],
			['Сан-Диего', 'шт. Калифорния', 1307402],
			['Даллас', 'шт. Техас', 1197816],
			['Сан-Хосе', 'шт. Калифорния', 945942]];
$total = 0;
$state_array = [];
foreach ($census as $value) {
	$total += $value[2];
	if (! array_key_exists($value[1], $state_array)) {
		$state_array[$value[1]] = 0;
	}
	$state_array[$value[1]] += $value[2];
	echo "<tr><td>$value[0]</td><td>$value[1]</td><td>$value[2]</td></tr>";
}
echo "<tr><td>Общая численность </td><td>$total</td></tr>";
foreach ($state_array as $key => $value) {
	echo "<tr><td>$key</td><td>$value</td></tr>";
}
echo "</table>";
// Задание 4 - тренировка с выводом массивов.
// Классы и идентификационные номера учащихся в классе
$class = ['Марина' => ['Класс' => '1a', 'id' => 1],
			'Женя' => ['Класс' => '1a', 'id' => 2]];
// Количество каждого товара в запасах на складе
$product = ['Shirt' => 10, 'Hat' => 20];
// Школьные обеды, состоящие из  разных блюд (закуски, салаты, напитки и т.д.), а также их стоимость на каждый день недели
$school_dinner = ['Monday' => ['Soup', 'tea', 'Bread', 25],
					'Tuesday' => ['Meat', 'Milk', 'Loaf', 23]];
// Имена членов вашей семьи
$family = ['Женя', 'Марина', 'Дема', 'Тимур'];
// Имена, возраст и родство членов вашей семьи
$family2 = ['Женя' => ['Age' => 39, 'Родство' => 'Муж'],
			'Марина' => ['Age' => 29, 'Родство' => 'Жена']];
// Глава 5
// Задание 1
function html_img($url, $alt = null, $height = null, $width = null) {
	$html = '<img src="' . $url . '"';
	if (isset($alt)) {
		$html .= ' alt="' . $alt . '"';
	}
	if (isset($height)) {
		$html .= ' height="' . $height . '"';
	}
	if (isset ($width)) {
		$html .= ' width="' . $width . '"';
	}
	$html .= '>';
	return $html;
}
echo html_img('https://habrastorage.org/webt/bu/fu/7_/bufu7_80gjx8jzlx4uhfqknrax4.png','текст',400);
echo "<hr>";
// Задание 2
$full_url = '/images/';
function html_img2($url) {
	$html2 = '<img src="' . $GLOBALS['full_url'] . $url . '">';
	return $html2;
}
echo html_img2('photo,png');
echo "<hr>";
// Задание 3
// require ('my_test-work.php');
// Задание 5 - перевести из rgb в хекс. Первый цвет rgb соответствует первым двум символам hex (шестнадцатиричная система счисления у хекса)
function to_hex($red, $green, $blue) {
	echo "#". dechex($red) . dechex($green) . dechex($blue);
}
to_hex(255,0,255);

**************************  GIT  *****34569871**********************************
Регистрация // Идем на https://github.com/ регистрируемся
Репозиторий // Создаем кнопкой New, даем логичное имя, оно формируется в общую ссылку твоего гита, вначале логин подставляется. Даем описание проекту, оставляем паблик и криэйт. При этом создается корневая папка, где будут храниться все файлы и папки проекта. + создается скрытая папка .git - тут хранится служебная информация и все версии проекта.
Связь Гита с Атомом // В гитхабе выбираем нужный репозиторий / Нажимае зеленую кнопку Clone or download / Копируем ссылку / Открываем коммандную строку атома - ctrl + shift +p / Вводим комманду клонирования - GitHub: Clone / В верхнее поле вставляем ссылку, в нижнее прописываем путь к папке (к серверу, предварительно на сервере создав домен с соответствующим названием)
Ветка / Branch // это параллельная версия репозитория, включеная в этот репозиторий, но не влияет на главную версию, тем самым позволяя свободно работать в параллельной. Когда внесли нужные изменения, можно объединить их с главной версией. В Атоме создается путем нажатия master/New Branch - тут же происходит переключение между ветками.



Введение
https://htmlacademy.ru/blog/useful/git/version-control-system
Глоссарий
https://htmlacademy.ru/blog/useful/git/git-and-github-glossary
Книга
https://git-scm.com/book/ru/v2
Интерактивный тур с настройкой
https://githowto.com/ru
Вопросы частые
http://firstaidgit.ru/#/
Как открыть пулл-реквест
https://isqua.ru/blog/2017/04/12/kak-otkryt-pull-riekviest-v-github-i-nie-oblazhatsia/
https://isqua.ru/blog/2017/04/13/kommientiruitie-svoi-pull-riekviesty/
Правильные коммиты
https://habr.com/ru/company/voximplant/blog/276695/




**************************  МАТЕМАТИКА  *****9563214****************************
Натуральное число // числа которые мы используем для подсчета предметов: 1,2,3... 0 сюда не входи. Можно еще их назвать простейщими числами.
Целые числа // к натуральным просто добавили 0 и отрицательные числа: 50, 0, -127... Числа с плавающей точкой не являются целыми числами.
Вещественное число // число с плавающей точкой, но может быть и любое целое число.
Действительное число = вещественное число
Рациональное число // отношение, деление, дробь - число представленное обыкновенной дробью, где в числителе целое число, а в знаменателе натуральное число. Дробь может быть отрицательная, может быть 0.
Натруальные, целые числа тоже можно представить в виде дроби, значит они тоже являются рациональными числами.
Иррациональное число -
Дробное число -
Комплексное число //  числа вида a + bi, где a,b — вещественные числа (действительные), i — мнимая единица (число, для которого выполняется равенство: i^2=-1), i = корень из -1. Левая часть от плюса действительная, а правая - мнимая часть.
Простое число // натуральное число больше 1, которое делится без остатка на единицу и само на себя. 4 делится без остатка на два: 11 11 - остатка нет. А вот 5 нельзя поделить без остатка ни на 2, ни на 3, ни на 4. Делим 5 на 2: 11 11 (4) - остаток 1, не делится уже на 2. Делим на 3: 111 - остаток 11 - не делится на 3. Делим на 4: 1111 - остаток 1.
Обыкновенная дробь -











1
